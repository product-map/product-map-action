name: ProductMap Map Generation
description: |
  Validates files, generates file maps via ProductMap tool, and retrieves generated map URLs.

branding:
  icon: "share-2"
  color: "blue"

inputs:
  repository_private:
    description: 'Whether the repository is private'
    required: true
  sha:
    description: 'GitHub SHA'
    required: true
  github_token:
    description: 'GitHub Token'
    required: true
  branch_name:
    description: 'Branch name'
    required: true
  expected_files:
    description: 'Expected files'
    required: false
  user_email:
    description: 'User email'
    required: false


permissions:
  contents: write
  pull-requests: write

runs:
  using: "composite"
  steps:
    - name: Add expected files path
      shell: bash
      run: |
        EXPECTED_FILES="${{ inputs.expected_files }}"
        # Update this list with the desired file paths
        echo "EXPECTED_FILES=${EXPECTED_FILES}" >> $GITHUB_ENV
        echo "File paths to be analyzed: ${EXPECTED_FILES}"

    # Step 1: Checkout the repository
    - name: Checkout Repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Ensures full commit history is fetched

    - name: Check repository visibility
      shell: bash
      run: |
        if [ "${{ inputs.repository_private }}" = "true" ]; then
          echo "This is a private repository."
          exit 1
        else
          echo "This is a public repository."
        fi

    # Step 2: Get GitHub username and email
    - name: Get GitHub User Info
      id: user-info
      shell: bash
      run: |
        # Fetch user info from the GitHub API
        curl -s -H "Authorization: Bearer ${{ inputs.github_token }}" \
          https://api.github.com/users/${GITHUB_ACTOR} > user.json

        # Extract username and email from API response
        NICKNAME=$(jq -r '.login' user.json)
        PUBLIC_EMAIL=$(jq -r '.email' user.json)

        # Handle if the email is null (public email not set)
        if [ "$PUBLIC_EMAIL" == "null" ]; then
          PUBLIC_EMAIL="No public email available"
        fi

        # Check if email is available from environment variable
        if [ "$PUBLIC_EMAIL" == "No public email available" ] && [ ! -z "${{ inputs.user_email }}" ]; then
          PUBLIC_EMAIL="${{ inputs.user_email }}"
        fi

        # If email is still not available, check the most recent commit email
        if [ "$PUBLIC_EMAIL" == "No public email available" ]; then
          COMMIT_EMAIL=$(git log -1 --pretty=format:'%ae')
          PUBLIC_EMAIL=$COMMIT_EMAIL
        fi
        
        # Save to environment variables
        echo "NICKNAME=$NICKNAME" >> $GITHUB_ENV
        echo "PUBLIC_EMAIL=$PUBLIC_EMAIL" >> $GITHUB_ENV

    - name: Get Modified Files
      id: modified_files
      shell: bash
      run: |

        # Print the current GitHub commit
        echo "Github current commit: ${{ inputs.sha }}"
    
        # Get the immediate previous commit, regardless of branch
        PREVIOUS_COMMIT=$(git rev-parse HEAD~1)
        echo "Previous commit: $PREVIOUS_COMMIT"
      
        # Get the list of modified files from the GitHub event
        git diff --name-only $PREVIOUS_COMMIT ${{ inputs.sha }} > changed_files.txt
        echo "Modified files:"
        cat changed_files.txt

        # Check if the list is empty, and add default data if needed
        if [ ! -s changed_files.txt ]; then
          echo "No modified files detected."
          exit 0
        fi

    - name: Filter Modified Files to obtain files to be processed
      id: filter_modified_files
      shell: bash
      run: |
        # Define the paths specified in `push: paths`
        EXPECTED_FILES=${{ env.EXPECTED_FILES }}
    
        # Read modified files from changed_files.txt
        if [ ! -f changed_files.txt ]; then
          echo "Error: changed_files.txt not found."
          exit 1
        fi
    
        MODIFIED_FILES=($(cat changed_files.txt))
        echo "Modified files: ${MODIFIED_FILES[@]}"
    
        # Initialize an array to store matching files
        MATCHING_FILES=()
    
        # Compare modified files with expected paths
        for file in "${MODIFIED_FILES[@]}"; do
          for expected in "${EXPECTED_FILES[@]}"; do
            if [ "$file" == "$expected" ]; then
              MATCHING_FILES+=("$file")
            fi
          done
        done
    
        # Output matching files
        if [ ${#MATCHING_FILES[@]} -eq 0 ]; then
          echo "No matching files found. Exiting."
          exit 0
        fi
    
        echo "Matching files: ${MATCHING_FILES[@]}"
        echo "${MATCHING_FILES[@]}" | tr ' ' '\n' > matching_files.txt
    
        # Store the matching files in a GitHub Action output and a new file
        MATCHING_FILES_STRING=$(cat matching_files.txt | paste -sd ',' -)
        echo "MATCHING_FILES_STRING=$MATCHING_FILES_STRING" >> $GITHUB_ENV
        echo "$MATCHING_FILES_STRING" > output_files.txt

    # New Step: Install ProductMap CLI
    - name: Install Python Package
      shell: bash
      run: |
        echo "Installing ProductMap CLI"
        pip install productmap-cli


    - name: Process Each Modified File
      shell: bash
      if: env.MATCHING_FILES_STRING != ''
      run: |
        ALL_RESPONSES=""
        for file in $(echo "$MATCHING_FILES_STRING" | tr ',' '\n'); do
          echo "Processing file: $file"
      
          # Step 2: Validate the file
          echo "Validate file in ProductMap API"
          pm-cli "$file" "$NICKNAME" "$PUBLIC_EMAIL" --action="validate"
          
          # Step 3: Send file to create a generated map
          echo "Send file to generate map in ProductMap API"
          pm-cli "$file" "$NICKNAME" "$PUBLIC_EMAIL" --action="generate" > response.json
          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
              echo "pm-cli failed with exit code $EXIT_CODE." >&2
              cat response.json
              exit $EXIT_CODE
          fi
      
          echo "Response from pm-cli:"
          cat response.json

          # Process each line of the response.json and extract `url` and `public_url`
          while IFS= read -r line; do
              # Check if the line contains valid JSON
              if echo "$line" | jq empty > /dev/null 2>&1; then
                  # Extract `url` and `public_url` from the JSON line
                  URL=$(echo "$line" | jq -r '.url')
                  PUBLIC_URL=$(echo "$line" | jq -r '.public_url')
      
                  # Append to the respective array if both values are found
                  if [ "$URL" != "null" ]; then
                      URLS+=("$URL")
                  fi
      
                  if [ "$PUBLIC_URL" != "null" ]; then
                      PUBLIC_URLS+=("$PUBLIC_URL")
                  fi
              fi
          done < response.json
          
          # Append the response to the combined output
          RESPONSE=$(tail -n 1 response.json)
          ALL_RESPONSES="${ALL_RESPONSES}\n${RESPONSE}"

          echo "Response from pm-cli:"
          echo "$RESPONSE"
        done

        # Output all responses for later use
        echo "ALL_RESPONSES=$ALL_RESPONSES" >> $GITHUB_ENV
        # Export the URLs and Public URLs arrays for the next steps
        echo "Exporting URLs and Public URLs for next steps:"
        echo "URLS=${URLS[@]}" >> $GITHUB_ENV
        echo "PUBLIC_URLS=${PUBLIC_URLS[@]}" >> $GITHUB_ENV

    - name: Ensure README.md exists
      shell: bash
      if: env.MATCHING_FILES_STRING != ''
      run: |
        # Check if README.md exists, if not, create it with a title
        if [ ! -f README.md ]; then
          echo "# Project Documentation" > README.md
        fi

    - name: Append JSON Responses
      shell: bash
      if: env.MATCHING_FILES_STRING != ''
      run: |
        echo "Appending responses to README.md"
        
        # Check if the header "## ProductMap file results" exists, and append if not present
        if ! grep -q "## ProductMap file results" README.md; then
            echo -e "\n# ProductMap file results\n" > README.md
        fi
        
        # Process "File URLs" header and replace URLs if they exist
        if grep -q "### File URLs" README.md; then
            echo "Found '### File URLs' header, replacing URLs below it."
            # Remove all URLs between "### File URLs" and the next section (if any)
            sed -i '/### File URLs/,/### /{//!d;}' README.md
        else
            echo -e "\n### File URLs:\n" >> README.md
        fi
        # Append new URLs
        for url in "${URLS[@]}"; do
            echo "$url" >> README.md
        done
        
        # Add a new line separator between the sections
        echo -e "\n" >> README.md
    
        # Process "Public file URLs" header and replace URLs if they exist
        if grep -q "### Public file URLs" README.md; then
            echo "Found '### Public file URLs' header, replacing URLs below it."
            # Remove all URLs between "### Public file URLs" and the next section (if any)
            sed -i '/### Public file URLs/,/### /{//!d;}' README.md
        else
            echo -e "\n### Public file URLs:\n" >> README.md
        fi
        # Append new Public URLs
        for public_url in "${PUBLIC_URLS[@]}"; do
            echo "$public_url" >> README.md
        done
    
        # Output updated README.md to verify the append
        echo "Updated README.md content:"

    - name: Run script to modify README.md
      shell: bash
      if: env.MATCHING_FILES_STRING != ''
      run: |
        echo "Adding timestamp to README.md"
        echo "\n\nLast updated on $(date)" >> README.md

    - name: Set up Git
      shell: bash
      if: env.MATCHING_FILES_STRING != ''
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"

    - name: Generate dynamic branch name
      if: env.MATCHING_FILES_STRING != ''
      id: generate_branch_name
      run: |
        # Generate branch name based on timestamp
        BRANCH_NAME="pm-$(date +'%Y%m%d%H%M%S')"  # Format: pm-YYYYMMDDHHMMSS
        echo "BRANCH_NAME=${BRANCH_NAME}" >> $GITHUB_ENV
        echo "Generated branch name: ${BRANCH_NAME}"

    - name: Create a new branch
      shell: bash
      if: env.MATCHING_FILES_STRING != ''
      run: |
        git checkout -b ${{ env.BRANCH_NAME }}  # Use the dynamically generated branch name

    - name: Make changes (e.g., create a file)
      shell: bash
      if: env.MATCHING_FILES_STRING != ''
      run: |
        echo "This is a new file created in the new branch" > newfile.txt
        git add README.md

    - name: Commit changes
      shell: bash
      if: env.MATCHING_FILES_STRING != ''
      run: |
        git commit -m "ProductMap analysis result" || echo "No changes to commit"

    - name: Push the new branch and commit
      shell: bash
      if: env.MATCHING_FILES_STRING != ''
      run: |
        git push --set-upstream origin ${{ env.BRANCH_NAME }}  # Push to the newly created branch and set upstream

    - name: Create a pull request
      shell: bash
      if: env.MATCHING_FILES_STRING != ''
      run: |
        # Create the PR using the GitHub API
        curl -X POST \
          -H "Authorization: token ${{ inputs.github_token }}" \
          -H "Accept: application/vnd.github.v3+json" \
          https://api.github.com/repos/${{ github.repository }}/pulls \
          -d '{
                "title": "Auto-generated PR for branch '${{ inputs.branch_name }}'",
                "head": "'${{ env.BRANCH_NAME }}'",
                "base": "main",
                "body": "This pull request was created automatically by GitHub Actions to merge the changes from '${{ inputs.branch_name }}' into the main branch."
              }'
